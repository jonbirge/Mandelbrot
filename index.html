<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Mandelbrot Set</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #fff;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    (() => {
      // Set up canvas and viewing parameters.
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const width = canvas.width, height = canvas.height;
      const maxIterations = 256;
      const initialStep = 16;  // Must be a power of 2; iterations will use: 16, 8, 4, 2, 1, 0.5
      const lastStep = 0.5;    // Stop refining when we reach this step size
      
      function getUrlParams() {
        const params = new URLSearchParams(window.location.search);
        return {
          centerX: parseFloat(params.get('centerX')) || -0.5,
          centerY: parseFloat(params.get('centerY')) || 0.0,
          scale: parseFloat(params.get('scale')) || 3.0
        };
      }

      function updateUrlParams(centerX, centerY, scale) {
        const params = new URLSearchParams();
        params.set('centerX', centerX);
        params.set('centerY', centerY);
        params.set('scale', scale);
        window.history.pushState({}, '', `${window.location.pathname}?${params}`);
      }

      const { centerX: initialCenterX, centerY: initialCenterY, scale: initialScale } = getUrlParams();
      let centerX = initialCenterX, centerY = initialCenterY, scale = initialScale;

      // Each click will recenter on the clicked point and zoom in by a factor of 4.
      let currentRenderId = 0;  // Increases with each new render (to discard late messages).
      let currentIteration = 0; // Tracks the current refinement iteration.
      
      // Create an ImageData buffer that we update progressively.
      let imageData = ctx.getImageData(0, 0, width, height);

      // Create a pool of Web Workers from an inline blob.
      const numWorkers = navigator.hardwareConcurrency || 4;
      console.log(`Using ${numWorkers} workers`);
      // const numWorkers = 8;
      const workers = [];
      
      function getColor(n, maxIterations) {
        if (n === maxIterations) {
          return { r: 0, g: 0, b: 0, a: 255 };  // Points inside the set: black.
        } else {
          // Smooth color gradient
          var t = n / maxIterations;
          var r = Math.floor(9 * (1 - t) * t * t * t * 255);
          var g = Math.floor(15 * (1 - t) * (1 - t) * t * t * 255);
          var b = Math.floor(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255);
          return { r: r, g: g, b: b, a: 255 };
        }
      }

      function blendPixel(imageData, x, y, color, weight) {
        if (x < 0 || x >= width || y < 0 || y >= height) return;
        const idx = (y * width + x) * 4;
        imageData.data[idx]     = (imageData.data[idx]     * (1-weight) + color.r * weight);
        imageData.data[idx + 1] = (imageData.data[idx + 1] * (1-weight) + color.g * weight);
        imageData.data[idx + 2] = (imageData.data[idx + 2] * (1-weight) + color.b * weight);
        imageData.data[idx + 3] = 255;
      }

      for (let i = 0; i < numWorkers; i++) {
        const worker = new Worker('mand_worker.js');
        worker.onmessage = function(e) {
          const data = e.data;
          // Discard any results from an outdated render.
          if (data.renderId !== currentRenderId) return;
          const s = data.s;
          const results = data.results;
          // For each computed point, fill its sÃ—s block in the image buffer.
          results.forEach(function (p) {
            const color = getColor(p.n, maxIterations);
            if (s >= 1) {
              // Integer block size - direct pixel assignment
              for (let dy = 0; dy < s; dy++) {
                for (let dx = 0; dx < s; dx++) {
                  const px = Math.floor(p.x + dx);
                  const py = Math.floor(p.y + dy);
                  blendPixel(imageData, px, py, color, 1.0);
                }
              }
            } else {
              // Fractional block size - anti-alias in RGB space
              const x0 = Math.floor(p.x), y0 = Math.floor(p.y);
              const x1 = Math.ceil(p.x + s), y1 = Math.ceil(p.y + s);
              
              for (let py = y0; py < y1; py++) {
                for (let px = x0; px < x1; px++) {
                  // Calculate overlap area for this pixel
                  const left = Math.max(p.x, px);
                  const right = Math.min(p.x + s, px + 1);
                  const top = Math.max(p.y, py);
                  const bottom = Math.min(p.y + s, py + 1);
                  
                  if (right > left && bottom > top) {
                    const weight = (right - left) * (bottom - top);
                    blendPixel(imageData, px, py, color, weight);
                  }
                }
              }
            }
          });
          // Update the canvas display.
          ctx.putImageData(imageData, 0, 0);
          // When every worker has returned, schedule the next (more refined) iteration.
          currentIterationPending--;
          if (currentIterationPending === 0) {
            // Proceed to the next iteration if above lastStep
            if (s > lastStep) {
              runIteration(s / 2, currentIteration + 1);
            }
          }
        };
        workers.push(worker);
      }
      
      // Global counter for the pending worker tasks.
      let currentIterationPending = 0;
      
      // runIteration dispatches tasks to all workers to compute new points for block size s.
      function runIteration(s, iteration) {
        if (s < lastStep) return;
        currentIteration = iteration;
        currentIterationPending = numWorkers;
        // Partition the vertical range into segments (one per worker).
        const segmentHeight = Math.ceil(height / numWorkers);
        for (let i = 0; i < numWorkers; i++) {
          const yStart = i * segmentHeight;
          const yEnd = Math.min(height, (i + 1) * segmentHeight);
          workers[i].postMessage({
            renderId: currentRenderId,
            s: s,
            iteration: iteration,
            yStart: yStart,
            yEnd: yEnd,
            width: width,
            height: height,
            centerX: centerX,
            centerY: centerY,
            scale: scale,
            maxIterations: maxIterations
          });
        }
      }
      
      // startRender resets the display and begins the progressive (iterative) computation.
      function startRender(newCenterX, newCenterY, newScale) {
        currentRenderId++;
        centerX = newCenterX;
        centerY = newCenterY;
        scale = newScale;
        updateUrlParams(centerX, centerY, scale);
        ctx.putImageData(imageData, 0, 0);
        // Begin with the coarsest resolution.
        runIteration(initialStep, 0);
      }
      
      // Start the initial render.
      startRender(centerX, centerY, scale);
      
      // When the user clicks, recenter on that complex coordinate and zoom in (scale divided by 4).
      canvas.addEventListener("click", function (e) {
        if (e.button === 0 && !hasDragged) { // Left click and no drag
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left, y = e.clientY - rect.top;
          // Map the clicked pixel to the complex plane.
          const newCenterX = centerX + (x - width / 2) * (scale / width);
          const newCenterY = centerY + (y - height / 2) * (scale / width);
          const newScale = scale / 4;
          startRender(newCenterX, newCenterY, newScale);
        }
      });

      // When the user right-clicks, recenter on that complex coordinate and zoom out (scale multiplied by 4).
      canvas.addEventListener("contextmenu", function (e) {
        e.preventDefault(); // Prevent the context menu from appearing
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        // Map the clicked pixel to the complex plane.
        const newCenterX = centerX + (x - width / 2) * (scale / width);
        const newCenterY = centerY + (y - height / 2) * (scale / width);
        const newScale = scale * 4;
        startRender(newCenterX, newCenterY, newScale);
      });

      // Handle the popstate event to re-render the view when navigating history.
      window.addEventListener('popstate', () => {
        const { centerX: newCenterX, centerY: newCenterY, scale: newScale } = getUrlParams();
        startRender(newCenterX, newCenterY, newScale);
      });

      let isDragging = false;
      let dragStartX = 0, dragStartY = 0;
      let dragStartCenterX = 0, dragStartCenterY = 0;
      let lastDragUpdate = 0;
      const dragUpdateInterval = 100; // ms
      let hasDragged = false;

      canvas.addEventListener("mousedown", function (e) {
        if (e.button === 0) { // Left button
          isDragging = true;
          hasDragged = false;
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          dragStartCenterX = centerX;
          dragStartCenterY = centerY;
        }
      });

      canvas.addEventListener("mousemove", function (e) {
        if (isDragging) {
          hasDragged = true;
          const now = Date.now();
          if (now - lastDragUpdate >= dragUpdateInterval) {
            lastDragUpdate = now;
            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;
            const newCenterX = dragStartCenterX - dx * (scale / width);
            const newCenterY = dragStartCenterY - dy * (scale / height);
            startRender(newCenterX, newCenterY, scale);
          }
        }
      });

      canvas.addEventListener("mouseup", function (e) {
        if (e.button === 0) { // Left button
          isDragging = false;
        }
      });

      canvas.addEventListener("mouseleave", function () {
        isDragging = false;
      });
      
    })();
  </script>
</body>
</html>
